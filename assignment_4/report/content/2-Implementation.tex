\section{Implementation}\label{sec:02_impl}
% What
This section describes the most important parts about the implementation of the application.
% What technology

\subsection{Loading and caching Data}\label{subsec:02_impl_data}
% What
The application needs to load the following data :
\begin{itemize}
\item Members
\item Member-Parties
\item Parties
\item Websites
\end{itemize}

\subsubsection{Loading single Data Objects}\label{subsubsec:02_impl_data_loading}
For each data, an API URL exists, that delivers the data in JSON format. Therefore, to load the data, a service is created for each single kind.

\Lst{lst:02_impl_data_memberservice} shows the implementation of the \texttt{MemberService} to load the Member JSON data. Each service follows the same routine:
\begin{enumerate}
\item Load the data from a given URL in JSON format
\item Map the response of each single object into an associated model
\end{enumerate}
% The listing
\begin{lstlisting}[label=lst:02_impl_data_memberservice, caption=\texttt{MemberService} implementation, language=java]
export class MemberService {

  private readonly membersApiUrl: string = 'https://data.parliament.scot/api/members';

  constructor(private http: HttpClient) { }

  public fetchData(): Observable<Member[]> {
    return this.http
      .get<MemberResponse[]>(this.membersApiUrl)
      .pipe(
        map(response => response.map(memberResponse => new Member(memberResponse)))
      );
  }
}
\end{lstlisting}

\subsubsection{Loading all Data at once}\label{subsubsec:02_impl_data_loadingAll}
% Intro of datacacheservice
The DataCacheService is responsible to load all the above mentioned data at once, and stores them in Observables to cache them.
% Interaction with components
After that, components are able to access the needed data models through an Observable (introduced in SEC XY).
% How
\Lst{lst:02_impl_data_dataserviceloading} shows a port of the implementation of the DataCacheService, how it uses the forkJoin method on all data services to load and join all data at once. After the data is loaded, it saves the models (generated by the associated service) in an Observable.
% The listing
\begin{lstlisting}[label=lst:02_impl_data_dataserviceloading, caption=\texttt{MemberService} implementation, language=java]
let requestSources: DataRequestSources = {
  members: this.memberService.fetchData(),
  memberParties: this.memberPartyService.fetchData(),
  parties: this.partyService.fetchData(),
  websites: this.websiteService.fetchData()
};

let promise = new Promise<DataResponse>((resolve, reject) =>
  forkJoin(requestSources)
  .subscribe(responses => {
    this.members$ = from(responses.members);
    this.memberParties$ = from(responses.memberParties);
    this.parties$ = from(responses.parties);
    this.websites$ = from(responses.websites);

    resolve({
      members$: this.members$,
      memberParties$: this.memberParties$,
      parties$: this.parties$,
      websites$: this.websites$
    })
  }, error => {
    reject(error);
  })
);
\end{lstlisting}

% Not all the time
In addition, the \texttt{DataCacheService} checks if the data has already been loaded. Otherwise, it just returns the already loaded data as \texttt{Observables}.


\subsection{Member List}\label{subsec:02_impl_memberlist}
% Intro
The MemberListComponent presents all members in a grid.

\begin{lstlisting}[label=lst:02_impl_memberlist_ngoninit, caption=\texttt{MemberService} implementation, language=java]
ngOnInit(): void {
  this.dataCacheService
  .fetchData()
  .then(dataResponse =>
    dataResponse.members$.subscribe(member => this.addMemberToGrid(member))
  )
  .catch(error => console.log('ERROR', error));
}
\end{lstlisting}

% How
\Lst{lst:02_impl_memberlist_ngoninit} shows the implementation of the ngOnInit method of the MemberListComponent. It uses the fetchData method of the DataCacheService to load all data (if not loaded before). Then, it subscribes to the members\$ property of the DataCacheService to add each member to a grid (2-dimensional array).

% Template listing
\begin{lstlisting}[label=lst:02_impl_memberlist_template, caption=\texttt{MemberService} implementation, language=HTML]
<div class="container">
  <div *ngFor="let row of grid" class="row member-row">
    <div *ngFor="let member of row" class="col-md-4">
      <app-member-card [member]="member"></app-member-card>
    </div>
  </div>
</div>
\end{lstlisting}
% Explain template
The grid is used to present all members of the parliament in a grid. \Lst{lst:02_impl_memberlist_template} shows the template of the MemberListComponent.


\subsection{Detail Page}\label{subsec:02_impl_detail}
% What
The \texttt{DetailPageComponent} displays the detail informations for a selected member.
% How
As introduced in SECTION OBEN, the \texttt{MemberListComponent} uses the \texttt{DataCacheService} to load and cache and all data. Therefore, inside the \texttt{DetailPageComponent} it is possible to easily subscribe to the Observables of the \texttt{DataCacheComponent} (introduced in SEC XY).

% on init
\begin{lstlisting}[label=lst:02_impl_detail_ngoninit, caption=\texttt{MemberService} implementation, language=java]
ngOnInit(): void {
  this.receiveMemberId();

  if (typeof this.memberId$ !== 'undefined') {
    this.dataCacheService.fetchData().then(_ =>
      this.memberId$?.subscribe(memberId => {
        this.receiveMember(memberId);
        this.receiveWebsites(memberId);
        this.receiveParties(memberId);
      })
    );
  }
}
\end{lstlisting}
% Get data
As \Lst{lst:02_impl_detail_ngoninit} show, this is done in the \texttt{ngOnInit} method of the \texttt{DetailPageComponent}.
First it receives the member ID, given in the URL.
Then, it is possible to get the member model, websites, and the member parties associated to the current member ID using filter operations. \Lst{lst:02_impl_detail_receivemember} shows the implementation of the \texttt{receiveMember} method, how the member model is received from the \texttt{members\$} Observable using a filter operation.
% receive member
\begin{lstlisting}[label=lst:02_impl_detail_receivemember, caption=\texttt{MemberService} implementation, language=java]
private receiveMember(memberId: number): void {
  this.dataCacheService.members$?.pipe(
    filter(member => member.id == memberId)
  ).subscribe(member => this.member = member);
}
\end{lstlisting}


% Get parties
Another important implementation, is way how parties are associated to a member. This implementation is shown in \Lst{lst:02_impl_detail_receiveParties}.
% Filter for member
At first, only the \texttt{MemberParties} objects are received that are associated to the current member using the member ID.
% Group together
Then, it is needed to group \texttt{MemberParties} together, because a member can be in multiple different parties or in the same party multiple times for different time intervals.

% Get memberships
After the \texttt{MemberParties} have been grouped, parties of the same type have to be merged together. At this point, it is important to save the smallest from date, and the largest until date (if defined, until can be \texttt{null}). Therefore, it is possible to show the length of the membership.

% Get parties
Next, the \texttt{Party} models need to be received from the \texttt{parties\$} Observable of the \texttt{DataCacheService} using the \texttt{partyId} of the \texttt{MemberParty}.
% Push to array
At last, the \texttt{Party} model with the from and until dates are pushed to an array, to list them in the \texttt{DetailPageComponent} template.
% Get Parties code
\begin{lstlisting}[label=lst:02_impl_detail_receiveParties, caption=\texttt{MemberService} implementation, language=java]
private receiveParties(memberId: number) {
  this.dataCacheService.memberParties$?.pipe(
    filter(memberParty => memberParty.personId == memberId),
    groupBy(memberParty => memberParty.partyId),
    mergeMap(group =>
      group.pipe(
        toArray(),
        map(groupedParties => this.generateMembership(groupedParties))
      )
    )
  ).subscribe(membership => {
    this.dataCacheService.parties$?.pipe(
      filter(party => party.id == membership.memberParty.partyId),
      map(party => {
        return {party, from: membership.from, until: membership.until};
      })
    ).subscribe(partyMembership => this.partyMemberships.push(partyMembership));
  });
}
\end{lstlisting}
